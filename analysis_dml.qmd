---
title: "Advanced Causal Inference (DML)"
subtitle: "Double Machine Learning: ATE, ATT, LATE, & SMOTE Operations"
author: "Vansh Singh Ruhela"
format:
  html:
    code-fold: true
    df-print: kable
    toc: true
    number-sections: true
    theme:
      light: cosmo
      dark: darkly
execute:
  echo: true
  warning: false
  message: false
---

# Introduction

This advanced analysis extends the standard Double Machine Learning (DML) framework to address complex causal inference challenges:
1.  **Class Imbalance**: Implementing **SMOTE** (Synthetic Minority Over-sampling Technique) to balance treatment groups.
2.  **Causal Estimands**: Estimating **ATE** (Average Treatment Effect), **ATT** (Average Treatment Effect on the Treated), and **LATE** (Local Average Treatment Effect) using Instrumental Variables.
3.  **Heterogeneity**: Investigating Conditional Average Treatment Effects (**CATE**).

We utilize `DoubleML`, `mlr3`, and custom simulation logic to ensure scientific rigor.

# Setup & Dependencies

```{r}
#| label: load-libs

library(DoubleML)
library(mlr3)
library(mlr3learners)
library(data.table)
library(ranger)
library(ggplot2)
library(readxl)
library(knitr)
library(kableExtra)
library(stats)
library(psych)

# Ensure reproducibility
set.seed(42)

# Load Data Securely
file_path <- "data/MAPQ_TKARONTO-3.xlsx"
data_raw <- read_excel(file_path, sheet = "MAPQ + KS + KnAcqS")

kable(head(data_raw, 5), caption = "Raw Data Preview") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

# Advanced Preprocessing: SMOTE

To address the potential imbalance in the `gender` treatment variable, we implement a custom SMOTE algorithm to generate synthetic samples for the minority class.

## Custom SMOTE Function

```{r}
#| label: custom-smote

custom_smote <- function(data, target, k = 5) {
  # Convert to data frame
  df <- as.data.frame(data)
  
  # Identify classes
  counts <- table(df[[target]])
  min_class <- names(which.min(counts))
  maj_class <- names(which.max(counts))
  
  min_data <- df[df[[target]] == min_class, ]
  maj_data <- df[df[[target]] == maj_class, ]
  
  # Calculate required synthetic samples
  n_diff <- nrow(maj_data) - nrow(min_data)
  
  if(n_diff <= 0) {
    message("Classes balanced or Minority >= Majority. No SMOTE needed.")
    return(df)
  }
  
  # Numeric columns for distance calculation
  numeric_cols <- sapply(min_data, is.numeric)
  min_data_num <- min_data[, numeric_cols]
  
  synthetic_rows <- list()
  
  # k-NN Logic
  k <- min(k, nrow(min_data) - 1)
  if (k < 1) k <- 1
  
  for (i in 1:n_diff) {
    # Random sample
    idx <- sample(1:nrow(min_data), 1)
    sample_pt <- min_data_num[idx, ]
    
    # Find neighbors
    dists <- apply(min_data_num, 1, function(x) sum((x - sample_pt)^2))
    dists[idx] <- Inf # Ignore self
    nn_indices <- order(dists)[1:k]
    
    # Select neighbor & interpolate
    neighbor_idx <- sample(nn_indices, 1)
    neighbor_pt <- min_data_num[neighbor_idx, ]
    gap <- runif(1)
    new_pt <- sample_pt + gap * (neighbor_pt - sample_pt)
    
    # Reconstruct
    new_row <- min_data[idx, ]
    new_row[numeric_cols] <- new_pt
    synthetic_rows[[i]] <- new_row
  }
  
  synth_df <- do.call(rbind, synthetic_rows)
  balanced_df <- rbind(df, synth_df)
  return(balanced_df)
}
```

## Applying SMOTE to MAPQ Data

```{r}
#| label: smote-application

# Select columns
cols <- c("KS", "gender", "age", "education", "workspace", "EE", "EA", "UA", "ER")
df_mapq <- na.omit(data_raw[, cols])

# Binarize Treatment (2 = Treated/Minority in this context assumption, 1 = Control)
df_mapq$gender_bin <- ifelse(df_mapq$gender == 2, 1, 0)
df_mapq$gender <- NULL

# Check Initial Balance
init_tab <- table(df_mapq$gender_bin)
print(paste("Initial Balance - 0:", init_tab[1], "| 1:", init_tab[2]))

# Apply SMOTE
df_balanced <- custom_smote(df_mapq, "gender_bin", k = 3)

# Check Final Balance
final_tab <- table(df_balanced$gender_bin)
print(paste("Final Balance - 0:", final_tab[1], "| 1:", final_tab[2]))

kable(as.data.frame(final_tab), col.names = c("Gender Group", "Count"), caption = "Post-SMOTE Class Distribution") %>%
  kable_styling(full_width = F)
```

# Double Machine Learning Analysis

## Model Configuration (IRM for ATE)

We use the **Interactive Regression Model (IRM)** to estimate the Average Treatment Effect (ATE).

```{r}
#| label: dml-setup

# Prepare Data.Table
dml_dt <- as.data.table(df_balanced)
x_cols <- c("age", "education", "workspace", "EE", "EA", "UA", "ER")

# Initialize Data Object
dml_data <- DoubleMLData$new(dml_dt,
                             y_col = "KS",
                             d_cols = "gender_bin",
                             x_cols = x_cols)

# Learners: Random Forest (Ranger)
ml_g <- lrn("regr.ranger", num.trees = 500, max.depth = 5, min.node.size = 2)
ml_m <- lrn("classif.ranger", num.trees = 500, max.depth = 5, min.node.size = 2, predict_type = "prob")

# Initialize Model
set.seed(123)
dml_irm <- DoubleMLIRM$new(dml_data,
                           ml_g = ml_g,
                           ml_m = ml_m,
                           n_folds = 5,
                           score = "ATE")
```

## Estimation Results & Propensity Score Diagnostics

```{r}
#| label: dml-fit-plot
#| fig.height: 8

dml_irm$fit()
dml_irm$summary()

# Propensity Score Overlap Plot
# Extracting propensity scores manually for visualization
# Note: DoubleML handles this internally, but visualization requires manual prediction or accessing internal artifacts
ps_model <- glm(gender_bin ~ age + education + workspace + EE + EA + UA + ER, 
                data = df_balanced, family = binomial)
df_balanced$ps_score <- predict(ps_model, type = "response")

ggplot(df_balanced, aes(x = ps_score, fill = factor(gender_bin))) +
  geom_density(alpha = 0.5) +
  scale_fill_manual(values = c("#3498db", "#e74c3c"), labels = c("Control", "Treated")) +
  labs(title = "Propensity Score Overlap (Post-SMOTE)",
       x = "Propensity Score", fill = "Group") +
  theme_minimal()
```

## Average Treatment Effect on the Treated (ATT)

```{r}
#| label: dml-att

dml_irm_att <- DoubleMLIRM$new(dml_data,
                               ml_g = ml_g,
                               ml_m = ml_m,
                               n_folds = 5,
                               score = "ATTE") # Estimating ATT
dml_irm_att$fit()
dml_irm_att$summary()
```

# Instrumental Variable Analysis (LATE)

```{r}
#| label: dml-late

# Synthetic Data for LATE
generate_late_data <- function(n = 2000) {
  age <- rnorm(n, 40, 10)
  income <- rlnorm(n, 10, 0.5)
  Z <- rbinom(n, 1, 0.5) # Instrument
  logits_d <- -2 + 0.05 * age + 2.0 * Z 
  prob_d <- 1 / (1 + exp(-logits_d))
  D <- rbinom(n, 1, prob_d)
  Y <- 100 + 5.0 * D + 0.5 * age + 0.001 * income + rnorm(n, 0, 5)
  data.frame(age=age, income=income, Z=Z, D=D, Y=Y)
}

df_synth <- generate_late_data()

# PLIV Model
dml_data_iv <- DoubleMLData$new(as.data.table(df_synth),
                                y_col = "Y",
                                d_cols = "D",
                                z_cols = "Z",
                                x_cols = c("age", "income"))

ml_l <- lrn("regr.ranger", num.trees = 100)
ml_m <- lrn("regr.ranger", num.trees = 100)
ml_r <- lrn("regr.ranger", num.trees = 100)

dml_pliv <- DoubleMLPLIV$new(dml_data_iv,
                             ml_l = ml_l,
                             ml_m = ml_m,
                             ml_r = ml_r,
                             n_folds = 3)

dml_pliv$fit()
dml_pliv$summary()
```
